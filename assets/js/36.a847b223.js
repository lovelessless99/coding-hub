(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{807:function(t,r,a){"use strict";a.r(r);var e=a(5),i=Object(e.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("本篇文章將介紹 Android 虛擬機的使用，以及當你下載 google play 應用程式時，你的手機到底幫你做了什麼事情。著重在應用程式從編譯到執行的流程。")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[a("img",{attrs:{src:"https://www.androidpolice.com/wp-content/themes/ap2/ap_resize/ap_resize.php?src=https%3A%2F%2Fwww.androidpolice.com%2Fwp-content%2Fuploads%2F2019%2F08%2F29-e1566447953900.png&w=728",alt:""}})]),t._v(" "),a("th",[a("img",{attrs:{src:"https://upload.wikimedia.org/wikipedia/commons/thumb/e/e6/Android_operating_system.gif/330px-Android_operating_system.gif",alt:""}})])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("Android 每一個版本都會用一個甜點命名，好ㄘ好ㄘ。不過可惜的是，Google 宣布從Android Q 開始不再以甜品命名 QQ")]),t._v(" "),a("td",[t._v("Android 各版本的彩蛋")])])])]),t._v(" "),a("h2",{attrs:{id:"一、-android-runtime-的簡介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、-android-runtime-的簡介"}},[t._v("#")]),t._v(" 一、 Android Runtime 的簡介")]),t._v(" "),a("h3",{attrs:{id:"_1-1-overview"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-overview"}},[t._v("#")]),t._v(" 1-1. Overview")]),t._v(" "),a("p",[t._v("Android Runtime（縮寫為ART），是一種在Android作業系統上的執行環境，Android 使用虛擬機去執行 android 應用程式的 APK 文件，在 Andoird 2.2 引入 Dalvik虛擬機，在虛擬機執行的過程中，不斷利用連續的效能分析搭配及時編譯技術來最佳化程式碼的執行。而後引進的 ART 可以把應用程式的 bytecode 直接轉換成 machine code，是 android 的新的虛擬機。ART引入了AOT這種預編譯技術，在應用程式安裝的過程中，ART就已經將所有的位元組碼重新編譯成了機器碼。因此在用 google play 下載應用程式時需要事先編譯，時間才會稍微久一點。應用程式執行過程中無需進行即時的編譯工作，只需要進行直接呼叫。因此，ART極大的提高了應用程式的執行效率，同時也減少了手機的電量消耗，提高了行動裝置的續航能力，在垃圾回收等機制上也有了較大的提升。接下來就仔細介紹 Android 機制。")]),t._v(" "),a("p",[t._v("先附上技術變遷的時間軸，讓你知道 Android 技術經歷了四次重大變遷。\n"),a("img",{attrs:{src:"https://miro.medium.com/max/700/1*oLO0ahW043xHq_Jg0q8twQ.png",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"_1-2-為什麼-android-需要使用虛擬機去執行程式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-為什麼-android-需要使用虛擬機去執行程式"}},[t._v("#")]),t._v(" 1-2. 為什麼 Android 需要使用虛擬機去執行程式 ?")]),t._v(" "),a("p",[t._v("你可能會覺得很奇怪，android OS 不是 unix-like 的作業系統嗎 ? 那為何程式不直接跑在上面就好了，還要隔一層虛擬機才能執行應用程式。參考"),a("a",{attrs:{href:"https://stackoverflow.com/questions/9913702/why-does-android-need-a-virtual-machinedvm/9913753",target:"_blank",rel:"noopener noreferrer"}},[t._v("這篇問答"),a("OutboundLink")],1),t._v("。")]),t._v(" "),a("h4",{attrs:{id:"_1-回到我們使用虛擬機的初衷-跨平台-write-once-run-every-where-。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-回到我們使用虛擬機的初衷-跨平台-write-once-run-every-where-。"}},[t._v("#")]),t._v(" 1. 回到我們使用虛擬機的初衷 - 跨平台 ( Write once, Run every where)。")]),t._v(" "),a("p",[t._v("現在的行動裝置硬體指令集架構的多樣性(x86, MIPS, ARM, RISC-V...)，我們需要藉由虛擬機利用中間程式碼的直譯，才能達到跨平台的效果。同時他們也借鏡 Java 的精神，設計出類似的執行流程，也把 Java 當成 android 程式設計的主要語言。")]),t._v(" "),a("h4",{attrs:{id:"_2-java-interface"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-java-interface"}},[t._v("#")]),t._v(" 2. Java Interface")]),t._v(" "),a("p",[t._v("雖然 Android OS 是使用 C 去撰寫的，但是操作作業系統的 OS API 是使用 Java 寫的，為什麼使用 Java 就如第一點所述，Google 工程師設計了很多 Android API 去使用 Java 的介面，而 Java 本身就是跑在虛擬機上。JVM 本身是一個 stack-based VM，而 Android 的 VM（稱為 Dalvik）是一個 register-based VM（這是為了生成更少的程式碼和更快的速度，以便從使用 Android 的任何設備中獲得更好的性能）。")]),t._v(" "),a("h3",{attrs:{id:"_1-3-process-vm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-process-vm"}},[t._v("#")]),t._v(" 1-3. Process VM")]),t._v(" "),a("p",[t._v("在先前的文章有提到 Process VM 的概念，簡單來說它就跟作業系統一般的 process 一樣，只是主要是讓程式語言在這個 Process 的環境下執行，所以又稱為高階程式語言虛擬機(high-level virtual machine)。")]),t._v(" "),a("p",[t._v("DVM 它類似於 JVM，你有 .java 文件，這些文件將被 java 編譯器編譯成 "),a("code",[t._v(".class")]),t._v("。"),a("code",[t._v(".class")]),t._v(" 檔案只不過是將由 JVM 運行的bytecode。JVM 可以執行在任何平台（windows、linux 或 unix）上。")]),t._v(" "),a("p",[t._v("在 android 中，這些文件也被編譯成 "),a("code",[t._v(".dex")]),t._v(" 文件並由 "),a("code",[t._v("DVM")]),t._v(" 運行。只是為了提供一個想法，當安裝應用程序時，Android 操作系統會分配唯一的 linux 用戶 ID，為每個應用程序分配一個 DVM。所以簡而言之，每個應用程序都有自己的 linux 進程、DVM 和 linux 用戶 ID。java 文件被編譯成 "),a("code",[t._v(".dex")]),t._v(" 文件，與 "),a("code",[t._v(".class")]),t._v(" 文件相比，它消耗的內存更少。")]),t._v(" "),a("p",[a("mark",[t._v("現在假設 10 個應用程序有 10 個單獨的 DVM，而 10 個單獨的 DVM 對於作業系統來說相當於有 10 個行程要處理。")]),t._v("\nAndroid OS 中的 dispatcher 或scheduler 負責處理這 10 個 Process，這就是我們有 android Activity 生命週期的原因。\n您需要 DVM 來維護每個行程（每個應用程序）的執行狀態。")]),t._v(" "),a("h2",{attrs:{id:"二-android-起源-dalvik-vm-jit-技術-android-kitkat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二-android-起源-dalvik-vm-jit-技術-android-kitkat"}},[t._v("#")]),t._v(" 二. Android 起源 - Dalvik VM + JIT 技術 ( Android KitKat )")]),t._v(" "),a("h3",{attrs:{id:"_2-1-什麼是-apk"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-什麼是-apk"}},[t._v("#")]),t._v(" 2-1. 什麼是 APK ?")]),t._v(" "),a("p",[t._v("除了在一般 Google Play 上下載應用程式，不知道大家有沒有自行下載過 APK 檔案安裝，有時後需要付費的 APP 被逆向工程破解後，你也可以透過 APK 檔案直接安裝免付錢的破解檔APK(爽死😎)，那到底什麼是APK，根據"),a("a",{attrs:{href:"https://zh.wikipedia.org/wiki/APK",target:"_blank",rel:"noopener noreferrer"}},[t._v("APK 的 wiki"),a("OutboundLink")],1),t._v("，一個Android應用程式的程式碼想要在Android裝置上執行，必須先進行編譯，然後被打包成為一個被Android系統的虛擬機所能辨識的檔案才可以被執行，而這種能被Android虛擬機辨識並執行的檔案格式便是「APK」。 一個APK檔案內包含被編譯的代碼檔案(.dex 檔案)，檔案資源（resources）， assets，憑證（certificates），和清單檔案（manifest file）。")]),t._v(" "),a("img",{attrs:{src:"https://i.imgur.com/Lm845zc.png",height:"200"}}),t._v(" "),a("p",[t._v("如上圖，一個 APK 通常由許多 "),a("code",[t._v(".dex")]),t._v(" 檔案，組合再一起，"),a("code",[t._v(".dex")]),t._v(" 包含我們撰寫的程式碼以及使用到的函式庫，為 Bytecode，就像是 Java 要先編譯成 "),a("code",[t._v(".class")]),t._v(" bytecode 後才能給 JVM 去直譯，"),a("code",[t._v(".dex")]),t._v(" 檔可以被 Android VM 所直譯。Bytecode 由我們的 android runtime interpreter 翻譯成 CPU 可以懂得指令，同時 ART 也掌管記憶體和垃圾管理。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://miro.medium.com/max/700/1*s_IOOXkGPxu-FM5hSe9hoA.png",alt:""}})]),t._v(" "),a("p",[t._v("從原始碼到APK的編譯流程如下，我找了兩張圖片可以交叉參考。")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("流程圖一")]),t._v(" "),a("th",[t._v("流程圖二")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[a("img",{attrs:{src:"https://pic1.zhimg.com/80/v2-11bacdf685c1464910f87479f260a014_1440w.jpg",alt:""}})]),t._v(" "),a("td",[a("img",{attrs:{src:"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6L3l5THZ5MjA0eFc5NHBUOXN2eVpZU0FjZFQwaWNMSlZDUms3Qk96QmhXUEdsVlZxOE44VzV4ejdpYlZlM2pWbGV2WDJpY2RTc2tZa0VFVmJnVUp1RVRzRXFRLzY0MA?x-oss-process=image/format,png",alt:""}})])])])]),t._v(" "),a("p",[t._v("1.通過AAPT(Android Assets Packing Tool)編譯資源文件，將資源文件打包編譯並生成生成R.java文件，就是放各種資源Id的那個文件。")]),t._v(" "),a("p",[t._v("2.通過 "),a("code",[t._v("Java 編譯器 javac")]),t._v(" 將 java 程式碼編譯為"),a("code",[t._v(".class")]),t._v(" bytecode")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[a("mark",[t._v("通過"),a("code",[t._v("Dalvik編譯器")]),t._v("將"),a("code",[t._v(".class")]),t._v("轉化為"),a("code",[t._v(".dex")])])])]),t._v(" "),a("p",[t._v("4.通過 Apk builder 將打包後的資源與"),a("code",[t._v(".dex")]),t._v("文件一起生成"),a("code",[t._v("APK")]),t._v("文件")]),t._v(" "),a("h3",{attrs:{id:"_2-2-用時間換空間的-dalvik-vm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-用時間換空間的-dalvik-vm"}},[t._v("#")]),t._v(" 2-2. 用時間換空間的 Dalvik VM")]),t._v(" "),a("p",[t._v("早期的智慧型手機硬體資源十分有限，記憶體容量都很小(256MB或更小)，為了最佳化記憶體的使用率，Dalvik VM 就隨之出生了，直譯時搭配及時編譯技術(Just in time compilation)，因為早期的 APP 規模較小，所以在做及時編譯技術時雖然會暫存熱點機器碼在記憶體，但是比起整個程式先編譯好再直接放入記憶體，直譯器邊翻譯邊執行再加上及時編譯技術犧牲少量的記憶體成本，換取更大的執行效率以及記憶體空間。但其實相當有限，因為早期記憶體容量比較小。")]),t._v(" "),a("p",[t._v("下圖為 Dalvik VM 啟動 APP 的流程")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://pic1.zhimg.com/80/v2-7ae741c2dfc5036a3eff58bc0e1dcdec_1440w.jpg",alt:""}})]),t._v(" "),a("p",[t._v("所以在 Android KitKat 的整體流程如下圖")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://miro.medium.com/max/700/0*AHlBCn_G4WB5R4RV.png",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"_2-3-android-kitkat-的優缺點"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-android-kitkat-的優缺點"}},[t._v("#")]),t._v(" 2-3. Android KitKat 的優缺點")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("優點")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("安裝速度超快")]),t._v(" "),a("p",[t._v("因為下載後程式碼不用編譯，直接用虛擬機執行 bytecode 就好。")])]),t._v(" "),a("li",[a("p",[t._v("儲存空間小")]),t._v(" "),a("p",[t._v("同樣的，下載後不需要編譯，直接執行載下來的 bytecode 就好。")])])])]),t._v(" "),a("li",[a("p",[t._v("缺點")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("dex 載入的時候會非常慢")]),t._v(" "),a("p",[t._v("因為在dex加載時會進行 dexopt，把 dex 檔案最佳化成 odex檔")])]),t._v(" "),a("li",[a("p",[t._v("JIT compilation Overhead")]),t._v(" "),a("p",[t._v("因為後期的 APP 規模逐漸成長，JIT 監控的負擔也越來越重，JIT 編譯時有時也會停頓。")])]),t._v(" "),a("li",[a("p",[t._v("Battery Overhead")]),t._v(" "),a("p",[t._v("因為 JIT 的 monitor 要一直監控，每次重新啟動都要重新監控、重新JIT編譯，花費很多 CPU 資源，對於手機來說非常耗電。")])]),t._v(" "),a("li",[a("p",[t._v("首次啟動執行很慢")]),t._v(" "),a("p",[t._v("因為在程式退出後重新執行時，剛剛JIT得到的熱點程式碼訊息都消失了，少了熱點程式碼的快取，除了執行時會比較慢，再來是 JIT 又要重新監控 = =")])])])])]),t._v(" "),a("p",[t._v("而後由於儲存裝置技術的進步，儲存空間變得非常寬裕，因此在 Android L後，就以嶄新的虛擬機 Android Runtime (ART) 來取代 Dalvik VM。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://miro.medium.com/max/700/1*qhzURrMnWEF6eP-3UAPWtg.png",alt:""}})]),t._v(" "),a("h2",{attrs:{id:"三-以空間換時間-全新-art-的時代-加入-aot-技術-android-lollipop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三-以空間換時間-全新-art-的時代-加入-aot-技術-android-lollipop"}},[t._v("#")]),t._v(" 三. 以空間換時間: 全新 ART 的時代 - 加入 AOT 技術   ( Android Lollipop )")]),t._v(" "),a("h3",{attrs:{id:"_3-1-aot-介紹"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-aot-介紹"}},[t._v("#")]),t._v(" 3-1. AOT 介紹")]),t._v(" "),a("p",[t._v("以下圖當作本小節的開頭，DVM 使用 JIT 方式編譯，ART 使用 AOT 方式編譯。\n"),a("img",{attrs:{src:"https://miro.medium.com/max/700/0*LMPhjF2BanM_9h8o.png",alt:""}})]),t._v(" "),a("p",[t._v("ART 在 Android L 中的工作方式與我們從 Dalvik 所知道的相比發生了 180 度的變化。ART 並沒有像在 Dalvik 中那樣使用及時編譯，而是使用了一種稱為提前編譯(AOT- Ahead of time compilation)的策略。這種方法極大地提高了執行時的效能，比及時編譯快 20 倍。ART是在 App 安裝的時候將 .apk 文件解壓，並將 .dex 預編譯為 .oat 可執行文件，當 App 啟動的時候就不需要在Runtime直譯執行了。")]),t._v(" "),a("p",[t._v("所以在 Android KitKat 的整體流程如下圖\n"),a("img",{attrs:{src:"https://miro.medium.com/max/700/0*tz0DhazhoXYZvn1H.png",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"_3-2-android-lollipop-優缺點"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-android-lollipop-優缺點"}},[t._v("#")]),t._v(" 3-2. Android Lollipop 優缺點")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("優點")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("執行時速度變快")]),t._v(" "),a("p",[t._v("ART 在下載時，已經預先編譯好了，因為已經是機器碼，不需要重新翻譯，執行時效率大幅提升。")])]),t._v(" "),a("li",[a("p",[t._v("執行時十分省電")]),t._v(" "),a("p",[t._v("因為不需要 JIT 的監控")])])])]),t._v(" "),a("li",[a("p",[t._v("缺點")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("App 的安裝、更新時間變長")]),t._v(" "),a("p",[t._v("因為 App 在安裝或更新的時候，都要進行 dex2oat 的動作，將 dex 進行預編譯，所以時間會較久。")])]),t._v(" "),a("li",[a("p",[t._v("佔用空間太大")]),t._v(" "),a("p",[t._v("不論是常用的、不常用的程式碼，都被編譯成一個二進位檔案，導致程式相當肥大，占用儲存設備大，同時也更吃記憶體。")])]),t._v(" "),a("li",[a("p",[t._v("捨棄 JIT - 靜態編譯成本")]),t._v(" "),a("p",[t._v("動態編譯技術可以在執行期獲得靜態編譯所沒有的熱點程式碼的資訊，來做效能最佳化。因此如果有些使用者不常用的程式碼被靜態編譯，浪費了編譯它的時間，也會讓這塊不常用的程式碼常駐在記憶體。")])])])])]),t._v(" "),a("p",[t._v("聰明的 Google 工程師，當然要改善這個大缺點，能省則省、能用就用。在 Android Nougat 版本，將會使用 "),a("code",[t._v("profile-guided compilation")]),t._v(" 的技術搭配及時編譯技術，同時結合動態編譯和靜態編譯的優點。")]),t._v(" "),a("h2",{attrs:{id:"四-摸斗摸斗嗨壓苦-profile-guided-compilation-aot-jit-android-nougat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四-摸斗摸斗嗨壓苦-profile-guided-compilation-aot-jit-android-nougat"}},[t._v("#")]),t._v(" 四. 摸斗摸斗嗨壓苦 - Profile-guided compilation : AOT + JIT ( Android Nougat )")]),t._v(" "),a("h3",{attrs:{id:"_4-1-profile-guided-compilation-介紹"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-profile-guided-compilation-介紹"}},[t._v("#")]),t._v(" 4-1. Profile-guided compilation 介紹")]),t._v(" "),a("p",[t._v("我選了三張圖，可以先參考一下。\n"),a("img",{attrs:{src:"https://miro.medium.com/max/700/1*hb26HQBJXRwl5lcsML5IoQ.png",alt:""}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://pic2.zhimg.com/80/v2-d3b288e7d03bebb85401e0200cdf20b5_1440w.jpg",alt:""}})]),t._v(" "),a("p",[a("img",{attrs:{src:"https://miro.medium.com/max/700/0*ZFpIMgR0kKniiery.png",alt:""}})]),t._v(" "),a("ol",[a("li",[a("p",[t._v("當你首次安裝並一個App的時候，AOT 不將.dex文件編譯為.oat文件，這一步減少了安裝時間，系統通過Interpreter的方式來啟動App。")])]),t._v(" "),a("li",[a("p",[t._v("當在App運行過程中探測到 hot code，就使用JIT編譯，這些通過JIT編譯的平台程式碼會被存儲在快取或記憶體中(JIT code cache)，加快下次執行的速度，並產生 profile 文件(編譯配置文件，記錄熱點函數訊息)儲存。")])]),t._v(" "),a("li",[a("p",[t._v("當設備處於空閒時間(IDLE)或充電狀態(charging)時，系統每隔一段時間就會去掃描 APP 目錄下 profile 文件(編譯所使用的Daemon Service，背景執行)，並啟動 AOT 編譯器(在這裡官方稱為 profile-guided compilation)，結合編譯配置文件將熱點代碼相關資訊編譯為 .oat 可執行文件。當再次執行App時，ART 就可以直接執行.oat文件了。")])])]),t._v(" "),a("p",[a("mark",[t._v("因為是用 JIT 產生的 profile 再引導 AOT 編譯，所以才稱為 profile-guided compilation。")])]),t._v(" "),a("p",[t._v("這個方法有幾個特點要注意")]),t._v(" "),a("ol",[a("li",[t._v("JIT的過程中，生成 Offline 的 Profile")]),t._v(" "),a("li",[t._v("系統守護行程服務，再背景監控，一旦在充電或是空閒，就會進行 AOT 編譯 profile")]),t._v(" "),a("li",[t._v("每個APP都會有自己的Profile文件，保存在App本身的Local Storage中")])]),t._v(" "),a("p",[t._v("整體的 Workflow 如下\n"),a("img",{attrs:{src:"https://pic3.zhimg.com/80/v2-4b8c58f328667c1fe2c43432940a71d6_1440w.jpg",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"_4-2-android-nougat-的優缺點"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-android-nougat-的優缺點"}},[t._v("#")]),t._v(" 4-2. Android Nougat 的優缺點")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("優點")]),t._v(" "),a("ul",[a("li",[t._v("更聰明、精準的編譯方式")])]),t._v(" "),a("p",[t._v("以往靜態編譯最佳化時，打不到(最佳化不到)真正的痛點，現在先使用 JIT 來探測一下熱點程式碼再引導 AOT 靜態編譯，節省更多空間，同時又可以高效率執行。")]),t._v(" "),a("ul",[a("li",[t._v("安裝、更新速度提升")])]),t._v(" "),a("p",[t._v("AOT 方式的壞處是下載後要先編譯，造成每次程式自己更新時會變慢，手機會變熱，現在下載後不用經過編譯的階段。")])]),t._v(" "),a("li",[a("p",[t._v("唯一的缺點")]),t._v(" "),a("p",[t._v("因為最一開始使用仍要經過 JIT，所以前幾次執行時會比較慢。")])])]),t._v(" "),a("p",[t._v("在時間跟空間完美的協調之後，仍然有一個汙點，Google 工程師眼裡揉不得沙子，生出了更進一步改善方法。")]),t._v(" "),a("h2",{attrs:{id:"五-最後的大雜交-profile-on-the-cloud-android-pie"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五-最後的大雜交-profile-on-the-cloud-android-pie"}},[t._v("#")]),t._v(" 五. 最後的大雜交 - Profile on the cloud ( Android Pie )")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://miro.medium.com/max/700/1*NlOHxgVWKD1OAPe696xxNw.png",alt:""}})]),t._v(" "),a("p",[t._v("雲端配置文件(Profile on the cloud) 背後的 "),a("mark",[t._v("主要思想是大多數人以非常相似的方式使用該應用程式")]),t._v("。因此，為了在安裝後立即提高性能，我們可以從已經使用過此應用程序的人那裡收集個人資料數據。此聚合配置文件資料用於為應用程序創建一個稱為共同核心配置文件(common core profile)的文件。")]),t._v(" "),a("p",[t._v("總而言之，就是蒐集使用者的資料，上傳每一個使用者的 profile，之後雲端會生成一個共同核心配置文件，共同核心配置文件相當於使用者的共同行為、常使用哪些功能的資訊，因此，當新用戶安裝該應用程序時，該文件將與該應用程序一起下載。ART 使用它來預編譯大多數用戶經常執行的類別和方法，這樣，新用戶在下載應用程序後立即獲得更好的性能。")]),t._v(" "),a("p",[t._v("由下圖可以看到啟動時間有了大幅的提升。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://miro.medium.com/max/700/1*9A7C2gtxTBvjhmvP7G4GWA.png",alt:""}})]),t._v(" "),a("p",[t._v("這方法提升啟動速度，ART 之後也會隨著使用者各自的行為，再對該使用者最常用的程式碼進行編譯。")]),t._v(" "),a("h2",{attrs:{id:"六、總結"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、總結"}},[t._v("#")]),t._v(" 六、總結")]),t._v(" "),a("p",[t._v("引入開頭的一張圖當作總結")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://miro.medium.com/max/700/1*oLO0ahW043xHq_Jg0q8twQ.png",alt:""}})]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Android 版本")]),t._v(" "),a("th",[t._v("特性")]),t._v(" "),a("th",[t._v("優點")]),t._v(" "),a("th",[t._v("缺點")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("Android KitKat")]),t._v(" "),a("td",[t._v("Android Runtime 使用 Dalvik VM 實現，搭配 JIT 及時編譯")]),t._v(" "),a("td",[t._v("省儲存空間跟記憶體空間 (對於早期的行動裝置)")]),t._v(" "),a("td",[a("ol",[a("li",[t._v("對於規模逐漸龐大的 APP，JIT 負擔變大，執行時有時候會變慢")]),a("li",[t._v("JIT monitor 要一直監控，手機會變熱且很耗電")])])])]),t._v(" "),a("tr",[a("td",[t._v("Android Lollip")]),t._v(" "),a("td",[t._v("Android Runtime 引入使用 AOT 編譯的 ART")]),t._v(" "),a("td",[a("ol",[a("li",[t._v("執行速度變更快(約20倍)")]),a("li",[t._v("更加省電，因為少了 JIT 一直監控")])])]),t._v(" "),a("td",[a("ol",[a("li",[t._v("因為要預編譯，更長的安裝、更新時間")]),a("li",[t._v("編譯後的檔案較大，使用更多的 RAM 跟 ROM")])])])]),t._v(" "),a("tr",[a("td",[t._v("Android Nougat")]),t._v(" "),a("td",[t._v("Profile-guided compilation ( JIT + AOT )")]),t._v(" "),a("td",[a("ol",[a("li",[t._v("使程式下載安裝、更新時不用預編譯，安裝更新速度變快")]),a("li",[t._v("最佳化程式碼時更加精準(Profile-guided，符合使用者行為)")]),a("li",[t._v("程式檔案較小")])])]),t._v(" "),a("td",[t._v("剛開始使用很慢，因為要先請 JIT 幫你看你常用哪個區段")])]),t._v(" "),a("tr",[a("td",[t._v("Android Pie")]),t._v(" "),a("td",[t._v("Profile in the Cloud")]),t._v(" "),a("td",[t._v("集合不同使用者的 profile 成 common core profile，之後下載後先編譯這段大家常用的程式碼，可以加速啟動的速度。")]),t._v(" "),a("td",[t._v("下載時要多花一些時間，程式下載時也多下載 common core profile，安裝要等一下下因為要編譯 profile，程式也稍微變大一些，但是我認為已經做出了最佳的取捨了 😉")])])])]),t._v(" "),a("p",[t._v("最後以 DVM 和 ART 的從原始碼的流程圖，結束本篇文章。\n"),a("img",{attrs:{src:"https://upload.wikimedia.org/wikipedia/commons/thumb/2/25/ART_view.png/600px-ART_view.png",alt:""}})]),t._v(" "),a("h2",{attrs:{id:"七、參考連結"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七、參考連結"}},[t._v("#")]),t._v(" 七、參考連結")]),t._v(" "),a("ol",[a("li",[a("p",[a("a",{attrs:{href:"https://proandroiddev.com/android-runtime-how-dalvik-and-art-work-6e57cf1c50e5",target:"_blank",rel:"noopener noreferrer"}},[t._v("Android Runtime — How Dalvik and ART work?(必看)"),a("OutboundLink")],1),t._v(" + "),a("a",{attrs:{href:"https://www.youtube.com/watch?v=0J1bm585UCc",target:"_blank",rel:"noopener noreferrer"}},[t._v("搭配正妹講解影片"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/95626955",target:"_blank",rel:"noopener noreferrer"}},[t._v("深入理解Android虛擬機及編譯系統"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/79634014",target:"_blank",rel:"noopener noreferrer"}},[t._v("Android虛擬機的JIT編譯器"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://levelup.gitconnected.com/android-dvm-vs-art-5687c7903e65",target:"_blank",rel:"noopener noreferrer"}},[t._v("Android: Dalvik vs ART"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://www.infoq.cn/article/android-in-depth-dalvik",target:"_blank",rel:"noopener noreferrer"}},[t._v("深入理解 Android（二）：Java 虚拟机 Dalvik"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://www.codenong.com/cs106791704/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Dalvik和ART編譯方式的演進"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://www.jianshu.com/p/a8cc7a92137c",target:"_blank",rel:"noopener noreferrer"}},[t._v("JVM、Dalvik、ART 介紹"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://www.slideshare.net/ssusere3af56/how-to-implement-a-simple-dalvik-virtual-machine",target:"_blank",rel:"noopener noreferrer"}},[t._v("How to implement a simple dalvik virtual machine"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://ithelp.ithome.com.tw/articles/10011817",target:"_blank",rel:"noopener noreferrer"}},[t._v("什麼是Dalvik Virtual Machine?"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://www.zhihu.com/question/21935487",target:"_blank",rel:"noopener noreferrer"}},[t._v("Android 的 ART 是什麼東西，有何作用？"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/19606414",target:"_blank",rel:"noopener noreferrer"}},[t._v("繼續談談下一代Android VM runtime: ART"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://data-flair.training/blogs/android-dalvik-virtual-machine/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Working of Dalvik Virtual Machine in Android"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://stackoverflow.com/questions/9913702/why-does-android-need-a-virtual-machinedvm/9913753",target:"_blank",rel:"noopener noreferrer"}},[t._v("Why does Android need a Virtual Machine(DVM)?"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://paul.pub/android-dalvik-vm/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Android上的Dalvik虛擬機"),a("OutboundLink")],1)])]),t._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://zh.wikipedia.org/wiki/APK",target:"_blank",rel:"noopener noreferrer"}},[t._v("APK 的 wiki"),a("OutboundLink")],1)])])])])}),[],!1,null,null,null);r.default=i.exports}}]);
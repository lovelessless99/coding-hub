(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{808:function(t,s,e){"use strict";e.r(s);var a=e(5),r=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"一、兩者介紹"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、兩者介紹"}},[t._v("#")]),t._v(" 一、兩者介紹")]),t._v(" "),e("h3",{attrs:{id:"_1-1-stack-based-vm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-stack-based-vm"}},[t._v("#")]),t._v(" 1-1. Stack-based VM")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E5%A0%86%E7%96%8A%E7%B5%90%E6%A7%8B%E6%A9%9F%E5%99%A8",target:"_blank",rel:"noopener noreferrer"}},[t._v("Stack-based VM Wiki"),e("OutboundLink")],1),t._v("\n這種類型的VM，記憶體以堆疊（Stack）儲存，適用於 0-operand instruction set，因為 memory fetch data 的動作都可以由 stack push / pop 來完成。執行運算時，由堆疊的頂端取出運算元，運算結束再存回堆疊的頂端。相較於累加器（採用 1-operand instruction set），和暫存器機（ 2-operand instruction set 或 3-operand instruction set），用零位址指令（ 0-operand instruction set）實作的堆疊機器，它的好處是程式碼密度（code density）相對較大，每個指令的占用的大小很小，可以用更少空間放更多指令，因此，它的程式通常較小。虛擬機例子如: JVM, .NET, php, python, Old Javascript engine")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"title"}),e("p",[t._v("什麼是 zero operand instruction ?")]),t._v(" "),e("p",[t._v("instruction 本身就是 op_code，省略所有運算元，並非所有指令都可以此種格式表示。zero operand instruction 以堆疊的資料結構來輔助運算，因此要用 stack-based machine 來運算，必須先轉成 postfix notation (後置式 - 運算子放在運算式後面)。")]),t._v(" "),e("p",[t._v("Ex: Y = (A-B)/(C+D*E)")]),t._v(" "),e("p",[t._v("先轉成後置式 : "),e("code",[t._v("AB-CDE*+/")])]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("指令")]),t._v(" "),e("th",[t._v("堆疊")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("PUSH A")]),t._v(" "),e("td",[t._v("A")])]),t._v(" "),e("tr",[e("td",[t._v("PUSH A")]),t._v(" "),e("td",[t._v("A B")])]),t._v(" "),e("tr",[e("td",[t._v("SUB")]),t._v(" "),e("td",[t._v("R1 ; R1 <- A-B")])]),t._v(" "),e("tr",[e("td",[t._v("PUSH C")]),t._v(" "),e("td",[t._v("R1 C")])]),t._v(" "),e("tr",[e("td",[t._v("PUSH D")]),t._v(" "),e("td",[t._v("R1 C D")])]),t._v(" "),e("tr",[e("td",[t._v("PUSH E")]),t._v(" "),e("td",[t._v("R1 C D E")])]),t._v(" "),e("tr",[e("td",[t._v("MUL")]),t._v(" "),e("td",[t._v("R1 C R2; R2 <- D*E")])]),t._v(" "),e("tr",[e("td",[t._v("ADD")]),t._v(" "),e("td",[t._v("R1 R3; R3<- C*R2")])]),t._v(" "),e("tr",[e("td",[t._v("DIV")]),t._v(" "),e("td",[t._v("R4; R4 <- R1/R3")])]),t._v(" "),e("tr",[e("td",[t._v("POP")]),t._v(" "),e("td",[t._v("Y <- R4")])])])])]),e("h3",{attrs:{id:"_1-2-register-based-vm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-register-based-vm"}},[t._v("#")]),t._v(" 1-2. Register-based VM")]),t._v(" "),e("p",[t._v("Register-based 適用於 2-operands 或 3-operands 的 instruction set，它不同於 Stack-based 的地方在於資料是從 registers fetch 而不是 stack，而每個 register 有它自己獨特的 address，這種性質讓 CPU 可以直接對 registers 存取資料，而不用藉由頻繁的 push/pop 動作來存取 stacks。虛擬機例子如: Lua, Dalvik, All modern Javascript engine")]),t._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"title"}),e("p",[t._v("Ex: A = B * C")]),t._v(" "),e("p",[t._v("2-operands instruction")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("[opcode][輸出運算元得address][第一個輸入運算元的地址][第二個輸入運算元的地址]\n\nMOV C, A ; C <- A (先儲存A的值)\nMUL C, B ; C <- C*B\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br")]),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br")])]),e("p",[t._v("3-operands instruction")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("[opcode][輸出運算元得address][第一個輸入運算元的地址][第二個輸入運算元的地址]\nMUL A, B, C\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br")]),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br")])])]),e("h2",{attrs:{id:"二、兩者比較"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、兩者比較"}},[t._v("#")]),t._v(" 二、兩者比較")]),t._v(" "),e("h3",{attrs:{id:"_2-1-instruction-dispatching"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-instruction-dispatching"}},[t._v("#")]),t._v(" 2-1. Instruction Dispatching")]),t._v(" "),e("p",[t._v("Instruction Dispatching 當得到當前要執行的指令的opcode（操作碼）之後，要跳轉到實現改操作碼的處理程序的動作。從記憶體讀取資料，並且跳到相對應的程式碼片段。")]),t._v(" "),e("p",[t._v("假如把解釋器核心看作一個FDX循環（fetch-decode/dispatch-execute loop），那麼最簡單的實現方式：")]),t._v(" "),e("div",{staticClass:"language-c line-numbers-mode"},[e("div",{staticClass:"highlight-lines"},[e("br"),e("div",{staticClass:"highlighted"},[t._v(" ")]),e("div",{staticClass:"highlighted"},[t._v(" ")]),e("br"),e("br"),e("br"),e("br"),e("br"),e("br"),e("br"),e("br"),e("br")]),e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("true"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  byte opcode "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("get_next_opcode")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// fetch")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("switch")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("opcode"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("                "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// dispatch")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("case")]),t._v(" Op_IADD"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" y "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("pop_int")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("             "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// execute")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" x "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("pop_int")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("             "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("push_int")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" y"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("               "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("case")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("                                  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// loop")]),t._v("\n")])]),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br")]),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br")])]),e("p",[t._v("switch-case的跳轉就是指令分派。")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("原始程式碼")]),t._v(" "),e("th",[t._v("Stack-based")]),t._v(" "),e("th",[t._v("Register-based")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("a = b + c")]),t._v(" "),e("td",[t._v("ILOAD c"),e("br"),t._v("ILOAD b"),e("br"),t._v("IADD"),e("br"),t._v("ISTORE a")]),t._v(" "),e("td",[t._v("IADD a b c")])])])]),t._v(" "),e("p",[t._v("Stack-based 需要四次的 instruction dispatching，而 Register-based 只需要一次 instruction dispatching。所以 Register-based 可以減少 instruction dispatching cost。")]),t._v(" "),e("h3",{attrs:{id:"_2-2-accessing-the-operands"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-accessing-the-operands"}},[t._v("#")]),t._v(" 2-2. Accessing the operands")]),t._v(" "),e("p",[t._v("Register-based 的會將 operands 儲存在不同 registers，相對地 Stack-based 會將每次要運算的operands先存到stack，要運算時就會pop\n出來交給 CPU 執行，而通常 Register-based 的 code size 會大於 Stack-based 的 code size，因為 Stack-based 只要記錄放置 operands 與\nstack point 的相對位置並使用 push 和 pop 的指令，而 Register-based 必須明確記住 operands 放在哪個 register。Register-based 的 code 也會因此用到較多的 memory，這也是為什麼 Stack-based 的架構會如此受到 VM 的喜愛。")]),t._v(" "),e("h3",{attrs:{id:"_2-3-performing-the-computation"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-performing-the-computation"}},[t._v("#")]),t._v(" 2-3. Performing the computation")]),t._v(" "),e("p",[t._v("在運算方面，Stack-based 的架構無法重複使用一些常用的 constants，相對地，若使用 Register-based 架構就可以解決這些問題，因為一旦將\nvalue load 進 register 之後，便可以重複使用直到 method 結束。另外，Stack-based VM 常常會有頻繁的 memory push/pop，使用 Register-based VM 可以利用一些最佳化的技術，減少不必要的 memory load。如：Forward/Backward Copy Propagation\nForward/Backward Copy Propagation 主要是用來消除一些不必要的 move 指令，它的原理是看前後幾個指令有沒有 dependency 的關係，例如下面的 4 行 source code")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("move r10, r1\nmove r11, r2\niadd r10, r10, r11\nmove r3 , r10\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br")]),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br")])]),e("p",[t._v("因為 第 1,2 行的 move 明顯是多餘的，因為不需要將 r1、r2 的資料搬到 r10、r11，而第 4 行的 move 也是同樣的意思，經過 Forward/Backward Copy Propagation 的步驟後可以簡化成下面的程式碼")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("iadd r3, r1, r2\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")]),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br")])]),e("h3",{attrs:{id:"_2-4-constant-optimization"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-constant-optimization"}},[t._v("#")]),t._v(" 2-4. Constant optimization")]),t._v(" "),e("p",[t._v("在 stack-based VM 無法將常用到的 constant 保存在 stack 中，但是 register-based VM 則可以預先 scan source code，並在程式執行一開始將一些可能會常用到的 constant 預先存放在某些 registers 中，這種作法可以減少多餘的 constant 的 load。")]),t._v(" "),e("p",[t._v("綜合以上，")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th"),t._v(" "),e("th",[t._v("stack-based VM")]),t._v(" "),e("th",[t._v("register-based VM")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("Instruction Dispatching")]),t._v(" "),e("td",[t._v("多")]),t._v(" "),e("td",[t._v("少")])]),t._v(" "),e("tr",[e("td",[t._v("Accessing the operands")]),t._v(" "),e("td",[t._v("記住operand和堆疊相對位址")]),t._v(" "),e("td",[t._v("要記住哪個 operand 放在哪個暫存器")])]),t._v(" "),e("tr",[e("td",[t._v("Code Size")]),t._v(" "),e("td",[t._v("小")]),t._v(" "),e("td",[t._v("大")])]),t._v(" "),e("tr",[e("td",[t._v("Memory 使用量")]),t._v(" "),e("td",[t._v("少")]),t._v(" "),e("td",[t._v("大")])]),t._v(" "),e("tr",[e("td",[t._v("Performing the computation")]),t._v(" "),e("td",[t._v("頻繁的 memory push/pop")]),t._v(" "),e("td",[t._v("Copy Propagation")])]),t._v(" "),e("tr",[e("td",[t._v("Constant optimization")]),t._v(" "),e("td",[t._v("無法將常用到的 constant 保存在 stack 中")]),t._v(" "),e("td",[t._v("可預先存放在某些 registers")])]),t._v(" "),e("tr",[e("td",[t._v("instruction set")]),t._v(" "),e("td",[t._v("0 operand")]),t._v(" "),e("td",[t._v("2 or 3 operand")])])])]),t._v(" "),e("p",[t._v("目前以 Register-based VM 最有效率，因為可以利用一些最佳化的技術減少不必要的資料搬移指令，但是 stack-based 也可以由 "),e("code",[t._v("top-of-stack caching")]),t._v(" 進行最佳化資料搬移的成本。就實現來說，因為 Stack-based 不用暫存器的分配(不需要指定顯式暫存器)，所以開發來說相對 Register-based VM 更容易，且 stack-based 零指令(zero operand) 使程式碼更小，更緊湊，適合應用在資源有限的環境中。")]),t._v(" "),e("p",[e("mark",[t._v("就一句話總結， Register-based 用空間換時間，執行速度較快但程式碼指令size較大，Register-based 用時間換空間，程式碼指令size較小旦資料搬移時間較多。")])]),t._v(" "),e("ul",[e("li",[t._v("JVM (stack-based)")])]),t._v(" "),e("p",[e("img",{attrs:{src:"http://dl.iteye.com/upload/attachment/157335/f2629890-07dc-34f5-9102-9274e5dafffc.gif",alt:""}})]),t._v(" "),e("ul",[e("li",[t._v("Dalvik VM (register-based)")])]),t._v(" "),e("p",[e("img",{attrs:{src:"http://dl.iteye.com/upload/attachment/157337/c6b17556-f5e0-3da2-979a-178cfe1f934f.gif",alt:""}})]),t._v(" "),e("p",[t._v("最後大推 "),e("a",{attrs:{href:"https://www.iteye.com/blog/rednaxelafx-492667",target:"_blank",rel:"noopener noreferrer"}},[t._v("虛擬機隨談（一）：解釋器，樹遍歷解釋器，基於棧與基於寄存器，大雜燴(推薦)"),e("OutboundLink")],1),t._v("，寫的真心不錯。")]),t._v(" "),e("h2",{attrs:{id:"三、參考連結"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、參考連結"}},[t._v("#")]),t._v(" 三、參考連結")]),t._v(" "),e("ol",[e("li",[e("p",[e("a",{attrs:{href:"https://www.csie.ntu.edu.tw/~b97080/HW-Review%20%20Reports_20100517/HW-Review%20%20Reports/Report/%5b25%5dStack-based%20or%20Register-based%20Virtual%20Machine.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("NTU 的作業(從這篇來的)"),e("OutboundLink")],1)])]),t._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://www.usenix.org/legacy/events/vee05/full_papers/p153-yunhe.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("Virtual Machine Showdown: Stack Versus Registers(很多文章參考這篇論文)"),e("OutboundLink")],1)])]),t._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://www.slideshare.net/nwind/virtual-machine-and-javascript-engine/28-Compiler_optimization",target:"_blank",rel:"noopener noreferrer"}},[t._v("Virtual machine and javascript engine"),e("OutboundLink")],1)])]),t._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://stackoverflow.com/questions/164143/registers-vs-stacks",target:"_blank",rel:"noopener noreferrer"}},[t._v("registers vs stacks"),e("OutboundLink")],1)])]),t._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://developer.aliyun.com/article/55902",target:"_blank",rel:"noopener noreferrer"}},[t._v("Stack based vs Register based Virtual Machine Architecture"),e("OutboundLink")],1)])]),t._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://www.iteye.com/blog/rednaxelafx-492667",target:"_blank",rel:"noopener noreferrer"}},[t._v("虛擬機隨談（一）：解釋器，樹遍歷解釋器，基於棧與基於寄存器，大雜燴(推薦)"),e("OutboundLink")],1)])]),t._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://www.zhihu.com/question/35777031",target:"_blank",rel:"noopener noreferrer"}},[t._v("棧式虛擬機和寄存器式虛擬機？"),e("OutboundLink")],1)])]),t._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://slidesplayer.com/slide/14659166/",target:"_blank",rel:"noopener noreferrer"}},[t._v("指令集架構 計算機也跟人類一樣"),e("OutboundLink")],1)])]),t._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://blog.louie.lu/2017/04/11/python-%E5%BA%95%E5%B1%A4%E9%81%8B%E4%BD%9C-01-%E8%99%9B%E6%93%AC%E6%A9%9F%E5%99%A8%E8%88%87-byte-code/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Python stack VM"),e("OutboundLink")],1)])]),t._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://www.zhihu.com/question/46088146",target:"_blank",rel:"noopener noreferrer"}},[t._v("Stack-based 的虛擬機有什麼常用的優化策略？"),e("OutboundLink")],1)])]),t._v(" "),e("li",[e("p",[e("a",{attrs:{href:"https://softwareengineering.stackexchange.com/questions/244354/why-do-vms-need-to-be-stack-machines-or-register-machines-etc",target:"_blank",rel:"noopener noreferrer"}},[t._v("Why do VMs need to be “stack machines” or “register machines” etc.?"),e("OutboundLink")],1)])])])])}),[],!1,null,null,null);s.default=r.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{792:function(t,e,r){"use strict";r.r(e);var a=r(5),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("p",[t._v("編譯器已經融入我們生活的每一個角落，在計算機科學上佔有一席之地，在本篇文章，先介紹本專案每一個 Part 的目的，並且介紹編譯器跟及時編譯器的目前技術發展，最後以 javascript 為例解釋及時編譯技術的應用。本專案的程式碼在我的"),r("a",{attrs:{href:"https://github.com/lovelessless99/Just-In-Time-Compiler",target:"_blank",rel:"noopener noreferrer"}},[t._v("github"),r("OutboundLink")],1),t._v("。")]),t._v(" "),r("h2",{attrs:{id:"一、專案說明"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一、專案說明"}},[t._v("#")]),t._v(" 一、專案說明")]),t._v(" "),r("p",[t._v("大家有沒有看過電影小姐好白，真的是我超愛的喜劇😆，百看不膩，在戲裡面，兩個黑人警探假扮兩個千金大小姐，布蘭妮威爾森跟蒂芬妮威爾森，裡面有個橋段")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("布蘭妮威爾森")]),t._v(" "),r("th",[t._v("蒂芬妮威爾森")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[r("img",{attrs:{src:"https://media.tenor.com/images/bdae0c8e46aa8d1b9a72725c207278f2/tenor.gif",alt:""}})]),t._v(" "),r("td",[r("img",{attrs:{src:"https://media.tenor.com/images/dd75ba41bf9ddbad10ecec4a412c312a/tenor.gif",alt:""}})])])])]),t._v(" "),r("p",[t._v("就用這個 BF 拉開本專案的序幕，BF 有三種意思")]),t._v(" "),r("ul",[r("li",[t._v("Bitch Fit 女生抓狂")]),t._v(" "),r("li",[t._v("Boyfriend 男朋友")]),t._v(" "),r("li",[t._v("Brainfuck 程式語言，本專案的主角")])]),t._v(" "),r("p",[t._v("回到正題，事實上，Brainfuck 語言短小精幹，是個圖靈完全的程式語言，然而可讀性極差，真的是會讓人 Bitch Fit，然而語法操作的簡單很適合拿來被我們拿來當作編譯器、及時編譯器的來源語言。經過本專案一步步的實作，由 JIT compiler 的牽線，讓 Brainfuck 語言從令人 Bitch Fit 變成我們的 Boyfriend，迫不及待了嗎 ? 接下來就是本專案的主題簡介。")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("Part")]),t._v(" "),r("th",[t._v("主題")]),t._v(" "),r("th",[t._v("說明")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("1")]),t._v(" "),r("td",[t._v("Simple JIT")]),t._v(" "),r("td",[t._v("利用 Dynasm 幫助建立簡單的 JIT")])]),t._v(" "),r("tr",[r("td",[t._v("2")]),t._v(" "),r("td",[t._v("BF compiler")]),t._v(" "),r("td",[t._v("建立簡單的 Brainfuck compiler 和 interpreter")])]),t._v(" "),r("tr",[r("td",[t._v("3")]),t._v(" "),r("td",[t._v("BF compiler interpreter comparison")]),t._v(" "),r("td",[t._v("比較 Brainfuck compiler interpreter 和 編譯器最佳化比較")])]),t._v(" "),r("tr",[r("td",[t._v("4")]),t._v(" "),r("td",[t._v("BF optimization")]),t._v(" "),r("td",[t._v("直譯器最佳化、實作及時編譯器")])]),t._v(" "),r("tr",[r("td",[t._v("5")]),t._v(" "),r("td",[t._v("Cross comparison")]),t._v(" "),r("td",[t._v("將所有的程式做一次性的結果探討")])]),t._v(" "),r("tr",[r("td",[t._v("6")]),t._v(" "),r("td",[t._v("Threaded Code")]),t._v(" "),r("td",[t._v("以 Threaded Code 的手法降低 Dispatch Overhead")])])])]),t._v(" "),r("h2",{attrs:{id:"二、why-compiler"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二、why-compiler"}},[t._v("#")]),t._v(" 二、Why Compiler ?")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("為什麼需要編譯器 ?")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("為了更快、更有效率的使用硬體，如 CPU、GPU等")])]),t._v(" "),r("li",[r("p",[t._v("程式碼可以跑在不同硬體平台上")])]),t._v(" "),r("li",[r("p",[t._v("廣義的編譯器定義是把 A 語言轉換成 B 語言，這個概念可以讓我們更方便的開發程式，這個以前端為例")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("Typescript  : 比 javascript 來的易除錯(因為是強型別、物件導向式)，快要變成前端的主流語言，我們需要編譯器的轉換，就可以更輕鬆撰寫前端程式")])]),t._v(" "),r("li",[r("p",[t._v("SASS / SCSS : 和上一點一樣，CSS 一遇到巢狀跟繼承問題，很難除錯，利用更好懂得格式再編譯成 CSS 就可以大幅減少開發負擔")])]),t._v(" "),r("li",[r("p",[t._v("markdown : 這個大家如果常常做筆記應該很熟悉，利用 markdown 的簡潔的語法自動生成整齊的網頁格式。")])])])])])]),t._v(" "),r("li",[r("p",[t._v("哪裡有編譯器的影子 ?")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("(行程)虛擬機")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("通常混和編譯加直譯")])]),t._v(" "),r("li",[r("p",[t._v("如 Google V8 、 Pypy 、 FlaCC 、 JVM 、 .NET 、 Android ART 、 OpenGL ( "),r("a",{attrs:{href:"http://slide.logan.tw/compiler-intro/#/4/2",target:"_blank",rel:"noopener noreferrer"}},[t._v("where to find compiler"),r("OutboundLink")],1),t._v(" )")])])])]),t._v(" "),r("li",[r("p",[t._v("一般編譯器")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("GCC、Clang : 將不同的程式語言轉成對應指令集架構的程式碼")])]),t._v(" "),r("li",[r("p",[t._v("Babeljs : 將程式碼編譯成 javascript，大幅降低前端開發的成本")])]),t._v(" "),r("li",[r("p",[t._v("SASS / SCSS compiler : 將 SASS / SCSS 編譯成 CSS")])]),t._v(" "),r("li",[r("p",[t._v("markdown compiler : 將 markdown 編譯成靜態 html 網頁")])])])])])]),t._v(" "),r("li",[r("p",[t._v("LLVM 編譯器框架，因為統一了 IR 以及對 IR 的優化，再也不用因為執行平台的不同要花大量時間重新設計，可以幫助我們快速建立一個 Compiler，現在很多編譯器都使用 LLVM 開發，LLVM 也有豐富的編譯輸出 (ARM, x86, Alpha, PowerPC)，LLVM的出現，讓不同的前端后端使用統一的LLVM IR ,如果需要支持新的程式語言或者新的設備平台，只需要開發對應的前端和後端即可。同時基於LLVM IR我們可以很快的開發自己的程式語言。")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("IR 圖一")]),t._v(" "),r("th",[t._v("IR 圖二")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[r("img",{attrs:{src:"https://pic3.zhimg.com/80/v2-64db6352bd23eb839ea4517ff70f2ba2_1440w.png",width:"500"}})]),t._v(" "),r("td",[r("img",{attrs:{src:"https://hacks.mozilla.org/files/2017/02/03-07-langs09-768x469.png",width:"500"}})])])])]),t._v(" "),r("p",[t._v("也因此，"),r("strong",[t._v("LLVM統一的IR是它成功的關鍵之一，也充分說明了一個優秀IR的重要性")]),t._v("。IR可以說是一種膠水語言，注重邏輯而去掉了平台相關的各種特性，這樣為了支持一種新語言或新硬體都會非常方便")])]),t._v(" "),r("li",[r("p",[t._v("根據"),r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/65452090",target:"_blank",rel:"noopener noreferrer"}},[t._v("此篇文章"),r("OutboundLink")],1),t._v("提到有限的精力跟無限的算力，深度學習編譯技術才會越來越重要，人會特定去最佳化某些算子(卷積)，而不一定適用網路的每一層。但深度學習編譯器可以幫助我們進行針對網路的每一層進行最佳化，通過（接近無限）的算力去適配每一個應用場景看到的網絡，這是深度學習編譯器比人工路線強的地方。"),r("strong",[t._v("編譯器可以達到更多的自動化")]),t._v("，以下節錄至該文章")]),t._v(" "),r("blockquote",[r("p",[t._v("當比較TVM和傳統方法的時候的時候，我們往往會發現：在標準的benchmark（如imagenet resnet）上，編譯帶來的提升可能只在10%到20%，但是一旦模型相對不標準化（如最近的OctConv，Deformable,甚至是同樣的resnet不同的輸入尺寸），編譯技術可以帶來的提升會非常巨大。原因也非常簡單，有限的精力使得參與優化的人往往關注有限的公開標準benchmark，但是我們的部署目標往往並非這些benchmark，自動化可以無差別地對我們關心的場景進行特殊優化。接近無限的算力和有限的精力的差別正是為什麼編譯技術一定會越來越重要的原因。")])]),t._v(" "),r("p",[r("img",{attrs:{src:"https://pic2.zhimg.com/80/v2-4f45f71b8e9e0338924e689a8c3b021d_1440w.png",alt:""}})]),t._v(" "),r("p",[t._v("另外，一個較新的技術 - TVM，引入 "),r("code",[t._v("graph compiler")]),t._v("，將深度學習的模型轉成 graph IR，對 IR 進行最佳化後，可以跑在如手機這種硬體資源較低的移動式裝置(當然會捨棄精度減少計算量，在精度和效率之間進行取捨)。和傳統編譯器不同的是，這類編譯器不光要解決跨平台，還有解決對神經網絡本身的最佳化問題，這樣原先一層的IR就顯得遠遠不夠，原因在於如果設計一個方便硬件最佳化的低階的語言，你幾乎很難從中推理一些神經網路中高階的概念進行最佳化")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("TVM 圖一")]),t._v(" "),r("th",[t._v("TVM 圖二")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[r("img",{attrs:{src:"https://pic3.zhimg.com/80/v2-cf84dfa43008de15457e188adca9a582_1440w.png",width:"500"}})]),t._v(" "),r("td",[r("img",{attrs:{src:"https://pic2.zhimg.com/80/v2-18d0443d567986dc4f34d23e4daa890d_1440w.jpg?source=1940ef5c",width:"500"}})])])])]),t._v(" "),r("p",[t._v("另外TVM的對手，XLA（加速線性代數）是針對線性代數的特定領域編譯器，可優化TensorFlow計算。結果是在服務器和移動平台上提高了速度，記憶體使用率和可移植性。")])])]),t._v(" "),r("p",[t._v("總結來說，因為根據摩爾定律，硬體晶片效能約每隔兩年便會增加一倍，但是近來計算能力的需求爆炸性的增加，例如深度學習，以及計算機架構的多樣性，摩爾定律逐漸跟不上計算能力的需求，所以我們需要編譯器，針對有限資源的硬體及架構產出最佳化、效率最高的程式碼")]),t._v(" "),r("h2",{attrs:{id:"三、compiler-language-vs-interpreter-language"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三、compiler-language-vs-interpreter-language"}},[t._v("#")]),t._v(" 三、Compiler Language vs Interpreter Language")]),t._v(" "),r("blockquote",[r("p",[r("a",{attrs:{href:"https://github.com/yaofly2012/note/issues/193",target:"_blank",rel:"noopener noreferrer"}},[t._v("參考連結"),r("OutboundLink")],1)])]),t._v(" "),r("p",[t._v("跟據翻譯的方式，分為編譯器和直譯器，以下為兩者比較")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th"),t._v(" "),r("th",[t._v("編譯器")]),t._v(" "),r("th",[t._v("直譯器")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("執行")]),t._v(" "),r("td",[t._v("要先編譯再執行")]),t._v(" "),r("td",[t._v("不用事先編譯")])]),t._v(" "),r("tr",[r("td",[t._v("啟動")]),t._v(" "),r("td",[t._v("慢 (要等編譯)")]),t._v(" "),r("td",[t._v("快(不用事先編譯)")])]),t._v(" "),r("tr",[r("td",[t._v("執行效率")]),t._v(" "),r("td",[t._v("快，編譯時還可以事先優化")]),t._v(" "),r("td",[t._v("慢")])]),t._v(" "),r("tr",[r("td",[t._v("重編譯")]),t._v(" "),r("td",[t._v("不用")]),t._v(" "),r("td",[t._v("每次啟動都要重編譯")])]),t._v(" "),r("tr",[r("td",[t._v("跨平台")]),t._v(" "),r("td",[t._v("差，換平台需要重編譯")]),t._v(" "),r("td",[t._v("好")])]),t._v(" "),r("tr",[r("td",[t._v("示意圖")]),t._v(" "),r("td",[r("img",{attrs:{src:"https://hacks.mozilla.org/files/2017/02/02-03-compile02-768x456.png",alt:""}})]),t._v(" "),r("td",[r("img",{attrs:{src:"https://hacks.mozilla.org/files/2017/02/02-02-interp02-768x447.png",alt:""}})])])])]),t._v(" "),r("p",[t._v("另外像 JVM，在 編譯 和 直譯 之間做一個取捨")]),t._v(" "),r("ol",[r("li",[t._v("先編譯成中間文件 ( Bytecode)")]),t._v(" "),r("li",[t._v("再直譯執行，並搭配 JIT compiler 的 runtime 優化")])]),t._v(" "),r("h2",{attrs:{id:"四、just-in-time-compiler-以-javascript-為例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#四、just-in-time-compiler-以-javascript-為例"}},[t._v("#")]),t._v(" 四、Just-in-time Compiler : 以 Javascript 為例")]),t._v(" "),r("p",[t._v("JIT Compiler 引入，使我們可以達到動態編譯的技術，以下以 Javascript 為例，這裡參考\n"),r("a",{attrs:{href:"https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/",target:"_blank",rel:"noopener noreferrer"}},[t._v("A crash course in just-in-time (JIT) compilers"),r("OutboundLink")],1)]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("Google V8 圖一")]),t._v(" "),r("th",[t._v("Google V8 圖二")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[r("img",{attrs:{src:"https://camo.githubusercontent.com/a19600604970dcbe59dec105638e9607e3e3ffccf5fd4512f74c13facb77ca2e/68747470733a2f2f696d6167652d7374617469632e7365676d656e746661756c742e636f6d2f3235362f3339392f3235363339393336352d356638326235653666303438615f61727469636c6578",width:"500"}})]),t._v(" "),r("td",[r("img",{attrs:{src:"https://i.stack.imgur.com/sAr01.png",width:"500"}})])])])]),t._v(" "),r("p",[t._v("先參照下列表格")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th"),t._v(" "),r("th",[t._v("Baseline compiler")]),t._v(" "),r("th",[t._v("Optimizing compiler")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("編譯,優化單位")]),t._v(" "),r("td",[t._v("程式碼行（stub）")]),t._v(" "),r("td",[t._v("函數")])]),t._v(" "),r("tr",[r("td",[t._v("編譯花費時間")]),t._v(" "),r("td",[t._v("短")]),t._v(" "),r("td",[t._v("長")])]),t._v(" "),r("tr",[r("td",[t._v("程式碼是否最佳化")]),t._v(" "),r("td",[t._v("否")]),t._v(" "),r("td",[t._v("是")])])])]),t._v(" "),r("img",{attrs:{src:"https://hacks.mozilla.org/files/2017/02/02-04-jit02-768x561.png",width:"500"}}),t._v(" "),r("p",[t._v("如上圖，JIT 會有一個監視者(monitor/profiler)，會監控程式碼執行的次數以及型別的使用")]),t._v(" "),r("img",{attrs:{src:"https://hacks.mozilla.org/files/2017/02/02-05-jit06-768x565.png",width:"500"}}),t._v(" "),r("p",[t._v('當程式碼開始"暖"起來，Baseline compiler 就會開始做事，根據'),r("a",{attrs:{href:"https://stackoverflow.com/questions/59638327/what-is-a-baseline-compiler",target:"_blank",rel:"noopener noreferrer"}},[t._v("此篇問答"),r("OutboundLink")],1)]),t._v(" "),r("blockquote",[r("p",[t._v("baseline compiler is to generate bytecode or machine code as fast as possible. This output code (machine code or intermediate code) however is not very optimized for a processor, hence it's very inefficient and slow in runtime.")])]),t._v(" "),r("p",[t._v("baseline compiler 盡快幫我們產生 bytecode 或是 machine code，baseline compiler 會把"),r("strong",[t._v("函數的每一行編譯成一個 stub")]),t._v("，換言之，是以函數的每一行為編譯單位，這些 stub 會被行號以及"),r("code",[t._v("變數型別")]),t._v('索引。如果監控者看到同樣的程式碼再出現一遍而且型別相同，就會把剛剛編譯過的程式碼直接丟回去執行，不用重編譯。可以加速執行時間。然而，baseline compiler 可能會做一點點最佳化處理，但是又不想耽誤執行時間太久，因此這些 code 並不是真正最佳化的code。頂多算是稍微好的code，但是執行效率仍然不夠好。\n然而，如果這段程式碼真的很"燙(hot)"，甚至占了大多數執行時間，那就非常有必要花費額外時間去做最佳化處理。')]),t._v(" "),r("img",{attrs:{src:"https://hacks.mozilla.org/files/2017/02/02-06-jit09-768x560.png",width:"500"}}),t._v(" "),r("p",[t._v('如上圖，上圖左邊是 baseline compiler 編譯好的程式碼(那些像白紙的東西)，不過如果這段程式碼真的很"燙(hot)"，monitor 會把這段程式碼送去 Optimizing compiler，產生出更高效能的程式碼。但是編譯時需要符合某個假設，那就是物件一致性。舉個例子，因為 javascript 是動態語言，可以在一個陣列裡面裝不同型別的物件，可能前 99 個物件都是房子，最後一個物件卻是怪物☢，所以 compiled code 在跑之前需要確定好假設是正確的，如果是對的，就跑這個 code，如果突然變怪物，那就會把這段最佳化的程式碼給丟掉💔，然後去跑 baseline compiled 版本，這個丟掉optimize 返回baseline過程稱為 '),r("strong",[t._v("解最佳化或反優化(deoptimization)")])]),t._v(" "),r("p",[t._v("雖然 Optimizing compiler 可以產生出更高效能的程式碼，但是可能會造成不可預期的效能問題，假設有個陣列有100個物件，這裡用虛擬碼宣告")]),t._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("[ 房子 * 9 + 怪物 * 1 ] * 10\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br")]),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br")])]),r("p",[t._v("當執行到第九次房子，監控者認為很熱時，送去最佳化編譯，但下一個遇到不符合假設的怪物物件，馬上又丟掉這段最佳化程式碼。這樣反覆最佳化 - 解最佳化，會嚴重影響到效能，那還不如乾脆執行 baseline compile 的程式碼就好，因此大部分的瀏覽器都會限制這段反覆次數，假設來回最佳化超過10次，就乾脆不最佳化💔")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/",target:"_blank",rel:"noopener noreferrer"}},[t._v("A crash course in just-in-time (JIT) compilers"),r("OutboundLink")],1),t._v("舉一個例子，Type specialization 看看簡單的程式碼背後的原理卻一大堆哲學，由於javascript 是動態弱型別語言，所以在執行時間時需要多做更多工作")]),t._v(" "),r("div",{staticClass:"language-javascript line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-javascript"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[t._v("arraySum")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("arr")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" sum "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" i "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" arr"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    sum "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" arr"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br"),r("span",{staticClass:"line-number"},[t._v("4")]),r("br"),r("span",{staticClass:"line-number"},[t._v("5")]),r("br"),r("span",{staticClass:"line-number"},[t._v("6")]),r("br")]),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br"),r("span",{staticClass:"line-number"},[t._v("4")]),r("br"),r("span",{staticClass:"line-number"},[t._v("5")]),r("br"),r("span",{staticClass:"line-number"},[t._v("6")]),r("br")])]),r("p",[r("code",[t._v("+=")]),t._v(" 看起來一個動作就好，感覺蠻簡單的，但是因為是動態型別，實際上背後偷偷執行更多東西，像是因為javascript是弱型別語言，javascript 允許字串和整數相加，例如")]),t._v(" "),r("div",{staticClass:"language-javascript line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-javascript"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[t._v("123")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token string"}},[t._v("'456'")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// a is '123456'")]),t._v("\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br")]),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br")])]),r("p",[r("code",[t._v("sum += arr[i]")]),t._v("，可能前 99 個都是整數，但是最後一個就是字串，導致剛剛最佳化程式碼不能用要捨棄，因為從整數的相加變成字串的相加，兩者的運算有本質上的不同。所以 JIT 會看這段 stub 是 monomorphic(不變的) 或是 polymorphic(變動的) (型別是否都相同)。如下圖")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("問題檢查樹狀圖")]),t._v(" "),r("th",[t._v("Compiler 檢查的過程")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[r("img",{attrs:{src:"https://hacks.mozilla.org/files/2017/02/02-08-decision_tree01-768x394.png",width:"500"}})]),t._v(" "),r("td",[r("img",{attrs:{src:"https://hacks.mozilla.org/files/2017/02/02-09-jit_loop02-768x496.png",width:"500"}})])])])]),t._v(" "),r("p",[t._v("假設沒有 Optimizing compiler，當這段code 要執行時，JIT 就要不斷檢查這些型別問題，在一個迴圈下，必須要不斷重複檢查審視這些問題，但其實可以加速執行，就出現\nOptimizing compiler，compiler 只需要把整段函數編譯，每次執行時都先檢查"),r("code",[t._v("arr[i]")]),t._v("的型別即可，"),r("strong",[t._v("根本不用每一行都檢查型別")]),t._v("，如下圖")]),t._v(" "),r("img",{attrs:{src:"https://hacks.mozilla.org/files/2017/02/02-10-jit_loop02-768x488.png",width:"500"}}),t._v(" "),r("p",[t._v("而火狐瀏覽器有做最佳化的處理，例如JIT再進入迴圈前會預先判斷是否整個陣列是整數型，減輕判斷時的負擔。")]),t._v(" "),r("h2",{attrs:{id:"參考連結"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#參考連結"}},[t._v("#")]),t._v(" 參考連結")]),t._v(" "),r("ol",[r("li",[r("p",[r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/29254171",target:"_blank",rel:"noopener noreferrer"}},[t._v("Deep Learning的IR之爭"),r("OutboundLink")],1)])]),t._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://github.com/yaofly2012/note/issues/193",target:"_blank",rel:"noopener noreferrer"}},[t._v("JS 及時編譯器 Just-In-Time (JIT) compilers"),r("OutboundLink")],1)])]),t._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://www.slideshare.net/jserv/what-can-compilers-do-for-us/16-LLVM",target:"_blank",rel:"noopener noreferrer"}},[t._v("What Can Compilers Do for Us?"),r("OutboundLink")],1)])]),t._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://www.zhihu.com/question/39304476",target:"_blank",rel:"noopener noreferrer"}},[t._v("為什麼這麼多人喜歡寫編譯器？"),r("OutboundLink")],1)])]),t._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://hackmd.io/@sysprog/SkBsZoReb?type=view",target:"_blank",rel:"noopener noreferrer"}},[t._v("虛擬機器設計與實作"),r("OutboundLink")],1)])]),t._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/65452090",target:"_blank",rel:"noopener noreferrer"}},[t._v("深度學習編譯技術的現狀和未來"),r("OutboundLink")],1)])]),t._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://www.zhihu.com/column/c_1169609848697663488",target:"_blank",rel:"noopener noreferrer"}},[t._v("深度學習編譯器學習筆記和實踐體會 (好專欄!) "),r("OutboundLink")],1)])]),t._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://www.slideshare.net/jserv/what-can-compilers-do-for-us",target:"_blank",rel:"noopener noreferrer"}},[t._v("Jserv 演講- 窮得只剩下 compiler"),r("OutboundLink")],1)])]),t._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/",target:"_blank",rel:"noopener noreferrer"}},[t._v("A crash course in just-in-time (JIT) compilers"),r("OutboundLink")],1)])]),t._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://stackoverflow.com/questions/59638327/what-is-a-baseline-compiler",target:"_blank",rel:"noopener noreferrer"}},[t._v("What is a baseline compiler?"),r("OutboundLink")],1)])])])])}),[],!1,null,null,null);e.default=s.exports}}]);
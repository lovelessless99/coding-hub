(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{785:function(t,_,r){"use strict";r.r(_);var e=r(5),v=function(t){t.options.__data__block__={chart_382ee148:'{\n  "type": "bar",\n  "data": {\n    "labels": ["interpreter", "interpreter opt1", "interpreter opt3", "interpreter opt2", "sed", "jit opcode", "compiler", "jit dynasm", "jit dynasm opt2", "jit dynasm opt1", "sed O2", "sed O1", "sed O3"],\n    "datasets": [{\n      "label": "Execution time (sec)",\n      "data": [129.15, 61.49, 50.66, 46.82, 18.20, 3.92, 3.85, 3.84, 1.26, 1.25, 1.20, 1.18, 1.17 ],\n      "backgroundColor": [\n        "rgba(255, 99, 132, 0.2)",\n        "rgba(255, 159, 64, 0.2)",\n        "rgba(255, 205, 86, 0.2)",\n        "rgba(75, 192, 192, 0.2)",\n        "rgba(54, 162, 235, 0.2)",\n        "rgba(153, 102, 255, 0.2)",\n        "rgba(201, 203, 207, 0.2)",\n        "rgba(255, 99, 132, 0.2)",\n        "rgba(255, 159, 64, 0.2)",\n        "rgba(255, 205, 86, 0.2)",\n        "rgba(75, 192, 192, 0.2)",\n        "rgba(54, 162, 235, 0.2)",\n        "rgba(153, 102, 255, 0.2)",\n        "rgba(201, 203, 207, 0.2)"\n      ],\n      "borderColor": [\n        "rgb(255, 99, 132)",\n        "rgb(255, 159, 64)",\n        "rgb(255, 205, 86)",\n        "rgb(75, 192, 192)",\n        "rgb(54, 162, 235)",\n        "rgb(153, 102, 255)",\n        "rgb(201, 203, 207)",\n        "rgb(255, 99, 132)",\n        "rgb(255, 159, 64)",\n        "rgb(255, 205, 86)",\n        "rgb(75, 192, 192)",\n        "rgb(54, 162, 235)",\n        "rgb(153, 102, 255)",\n        "rgb(201, 203, 207)"\n      ],\n      "borderWidth": 1\n    }]\n  },\n  "options": {\n    "scales": {\n      "yAxes": [{\n        "ticks": {\n          "beginAtZero": true\n        }\n      }]\n    }\n  }\n}',chart_64a561da:'{\n  "type": "bar",\n  "data": {\n    "labels": ["interpreter", "interpreter opt1", "interpreter opt3", "interpreter opt2", "sed"],\n    "datasets": [{\n      "label": "Execution time (sec)",\n      "data": [129.15, 61.49, 50.66, 46.82, 18.20],\n      "backgroundColor": [\n        "rgba(255, 99, 132, 0.2)",\n        "rgba(255, 159, 64, 0.2)",\n        "rgba(255, 205, 86, 0.2)",\n        "rgba(75, 192, 192, 0.2)",\n        "rgba(54, 162, 235, 0.2)"\n      ],\n      "borderColor": [\n        "rgb(255, 99, 132)",\n        "rgb(255, 159, 64)",\n        "rgb(255, 205, 86)",\n        "rgb(75, 192, 192)",\n        "rgb(54, 162, 235)"\n      ],\n      "borderWidth": 1\n    }]\n  },\n  "options": {\n    "scales": {\n      "yAxes": [{\n        "ticks": {\n          "beginAtZero": true\n        }\n      }]\n    }\n  }\n}',chart_64a55998:'{\n  "type": "bar",\n  "data": {\n    "labels": ["interpreter opt1", "interpreter opt3", "interpreter opt2", "jit_dynasm"],\n    "datasets": [{\n      "label": "Execution time (sec)",\n      "data": [61.49, 50.66, 46.82, 3.84],\n      "backgroundColor": [\n        "rgba(255, 99, 132, 0.2)",\n        "rgba(255, 159, 64, 0.2)",\n        "rgba(255, 205, 86, 0.2)",\n        "rgba(75, 192, 192, 0.2)"\n      ],\n      "borderColor": [\n        "rgb(255, 99, 132)",\n        "rgb(255, 159, 64)",\n        "rgb(255, 205, 86)",\n        "rgb(75, 192, 192)"\n      ],\n      "borderWidth": 1\n    }]\n  },\n  "options": {\n    "scales": {\n      "yAxes": [{\n        "ticks": {\n          "beginAtZero": true\n        }\n      }]\n    }\n  }\n}',chart_64a54ae2:'{\n  "type": "bar",\n  "data": {\n    "labels": ["jit opcode", "compiler", "jit dynasm", "jit dynasm opt2", "jit dynasm opt1", "sed O2", "sed O1", "sed O3"],\n    "datasets": [{\n      "label": "Execution time (sec)",\n      "data": [3.92, 3.85, 3.84, 1.26, 1.25, 1.20, 1.18, 1.17 ],\n      "backgroundColor": [\n        "rgba(255, 99, 132, 0.2)",\n        "rgba(255, 159, 64, 0.2)",\n        "rgba(255, 205, 86, 0.2)",\n        "rgba(75, 192, 192, 0.2)",\n        "rgba(54, 162, 235, 0.2)",\n        "rgba(153, 102, 255, 0.2)",\n        "rgba(201, 203, 207, 0.2)",\n        "rgba(255, 99, 132, 0.2)",\n        "rgba(255, 159, 64, 0.2)",\n        "rgba(255, 205, 86, 0.2)"\n      ],\n      "borderColor": [\n        "rgb(255, 99, 132)",\n        "rgb(255, 159, 64)",\n        "rgb(255, 205, 86)",\n        "rgb(75, 192, 192)",\n        "rgb(54, 162, 235)",\n        "rgb(153, 102, 255)",\n        "rgb(201, 203, 207)",\n        "rgb(255, 99, 132)",\n        "rgb(255, 159, 64)"\n      ],\n      "borderWidth": 1\n    }]\n  },\n  "options": {\n    "scales": {\n      "yAxes": [{\n        "ticks": {\n          "beginAtZero": true\n        }\n      }]\n    }\n  }\n}'}},n=Object(e.a)({},(function(){var t=this,_=t.$createElement,r=t._self._c||_;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"part-5-cross-comparison"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#part-5-cross-comparison"}},[t._v("#")]),t._v(" Part 5. Cross Comparison")]),t._v(" "),r("p",[t._v("終於進入我們的最終章，一個大亂鬥的時代 ~")]),t._v(" "),r("p",[t._v("進到 Part 5 資料夾，執行")]),t._v(" "),r("div",{staticClass:"language-bash line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-bash"}},[r("code",[r("span",{pre:!0,attrs:{class:"token function"}},[t._v("make")]),t._v("\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br")]),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br")])]),r("p",[t._v("就可以自動編譯所有的程式及輸出比較表格與圖片，\n首先先來看輸出的表格以及圖片，很美吧😁")]),t._v(" "),r("Chart",{attrs:{id:"chart_382ee148",code:t.$dataBlock.chart_382ee148}}),r("table",[r("thead",[r("tr",[r("th",[t._v("Rank")]),t._v(" "),r("th",[t._v("program")]),t._v(" "),r("th",[t._v("real")]),t._v(" "),r("th",[t._v("user")]),t._v(" "),r("th",[t._v("system")]),t._v(" "),r("th",[t._v("Execution Time")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("0")]),t._v(" "),r("td",[t._v("interpreter")]),t._v(" "),r("td",[t._v("2:18.71")]),t._v(" "),r("td",[t._v("129.01")]),t._v(" "),r("td",[t._v("0.14")]),t._v(" "),r("td",[t._v("129.15")])]),t._v(" "),r("tr",[r("td",[t._v("1")]),t._v(" "),r("td",[t._v("interpreter_opt1")]),t._v(" "),r("td",[t._v("1:02.82")]),t._v(" "),r("td",[t._v("61.48")]),t._v(" "),r("td",[t._v("0.01")]),t._v(" "),r("td",[t._v("61.49")])]),t._v(" "),r("tr",[r("td",[t._v("2")]),t._v(" "),r("td",[t._v("interpreter_opt3")]),t._v(" "),r("td",[t._v("0:53.23")]),t._v(" "),r("td",[t._v("50.54")]),t._v(" "),r("td",[t._v("0.12")]),t._v(" "),r("td",[t._v("50.66")])]),t._v(" "),r("tr",[r("td",[t._v("3")]),t._v(" "),r("td",[t._v("interpreter_opt2")]),t._v(" "),r("td",[t._v("0:47.69")]),t._v(" "),r("td",[t._v("46.79")]),t._v(" "),r("td",[t._v("0.03")]),t._v(" "),r("td",[t._v("46.82")])]),t._v(" "),r("tr",[r("td",[t._v("4")]),t._v(" "),r("td",[t._v("sed")]),t._v(" "),r("td",[t._v("0:19.47")]),t._v(" "),r("td",[t._v("18.17")]),t._v(" "),r("td",[t._v("0.03")]),t._v(" "),r("td",[t._v("18.20")])]),t._v(" "),r("tr",[r("td",[t._v("5")]),t._v(" "),r("td",[t._v("jit_opcode")]),t._v(" "),r("td",[t._v("0:04.35")]),t._v(" "),r("td",[t._v("3.89")]),t._v(" "),r("td",[t._v("0.03")]),t._v(" "),r("td",[t._v("3.92")])]),t._v(" "),r("tr",[r("td",[t._v("6")]),t._v(" "),r("td",[t._v("compiler")]),t._v(" "),r("td",[t._v("0:04.20")]),t._v(" "),r("td",[t._v("3.85")]),t._v(" "),r("td",[t._v("0.00")]),t._v(" "),r("td",[t._v("3.85")])]),t._v(" "),r("tr",[r("td",[t._v("7")]),t._v(" "),r("td",[t._v("jit_dynasm")]),t._v(" "),r("td",[t._v("0:04.75")]),t._v(" "),r("td",[t._v("3.81")]),t._v(" "),r("td",[t._v("0.03")]),t._v(" "),r("td",[t._v("3.84")])]),t._v(" "),r("tr",[r("td",[t._v("8")]),t._v(" "),r("td",[t._v("jit_dynasm_opt2")]),t._v(" "),r("td",[t._v("0:01.37")]),t._v(" "),r("td",[t._v("1.25")]),t._v(" "),r("td",[t._v("0.01")]),t._v(" "),r("td",[t._v("1.26")])]),t._v(" "),r("tr",[r("td",[t._v("9")]),t._v(" "),r("td",[t._v("jit_dynasm_opt1")]),t._v(" "),r("td",[t._v("0:01.46")]),t._v(" "),r("td",[t._v("1.25")]),t._v(" "),r("td",[t._v("0.00")]),t._v(" "),r("td",[t._v("1.25")])]),t._v(" "),r("tr",[r("td",[t._v("10")]),t._v(" "),r("td",[t._v("sed_O2")]),t._v(" "),r("td",[t._v("0:01.21")]),t._v(" "),r("td",[t._v("1.20")]),t._v(" "),r("td",[t._v("0.00")]),t._v(" "),r("td",[t._v("1.20")])]),t._v(" "),r("tr",[r("td",[t._v("11")]),t._v(" "),r("td",[t._v("sed_O1")]),t._v(" "),r("td",[t._v("0:01.20")]),t._v(" "),r("td",[t._v("1.17")]),t._v(" "),r("td",[t._v("0.01")]),t._v(" "),r("td",[t._v("1.18")])]),t._v(" "),r("tr",[r("td",[t._v("12")]),t._v(" "),r("td",[t._v("sed_O3")]),t._v(" "),r("td",[t._v("0:01.18")]),t._v(" "),r("td",[t._v("1.17")]),t._v(" "),r("td",[t._v("0.00")]),t._v(" "),r("td",[t._v("1.17")])])])]),t._v(" "),r("p",[t._v("可以發現我們從頭到尾的心路歷程，從最簡單的 interpreter 一路走到 JIT compiler，最後我們經過最佳化的JIT compiler 和 編譯器方法最佳化的速度幾乎一致，及時編譯器的效果很猛吧😁，接下來三個小節就來探討各個不同比較的組合。")]),t._v(" "),r("h2",{attrs:{id:"_5-1-interpreter-家族"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-interpreter-家族"}},[t._v("#")]),t._v(" 5.1 Interpreter 家族")]),t._v(" "),r("Chart",{attrs:{id:"chart_64a561da",code:t.$dataBlock.chart_64a561da}}),r("table",[r("thead",[r("tr",[r("th",[t._v("Rank")]),t._v(" "),r("th",[t._v("program")]),t._v(" "),r("th",[t._v("real")]),t._v(" "),r("th",[t._v("user")]),t._v(" "),r("th",[t._v("system")]),t._v(" "),r("th",[t._v("Execution Time")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("0")]),t._v(" "),r("td",[t._v("interpreter")]),t._v(" "),r("td",[t._v("2:18.71")]),t._v(" "),r("td",[t._v("129.01")]),t._v(" "),r("td",[t._v("0.14")]),t._v(" "),r("td",[t._v("129.15")])]),t._v(" "),r("tr",[r("td",[t._v("1")]),t._v(" "),r("td",[t._v("interpreter_opt1")]),t._v(" "),r("td",[t._v("1:02.82")]),t._v(" "),r("td",[t._v("61.48")]),t._v(" "),r("td",[t._v("0.01")]),t._v(" "),r("td",[t._v("61.49")])]),t._v(" "),r("tr",[r("td",[t._v("2")]),t._v(" "),r("td",[t._v("interpreter_opt3")]),t._v(" "),r("td",[t._v("0:53.23")]),t._v(" "),r("td",[t._v("50.54")]),t._v(" "),r("td",[t._v("0.12")]),t._v(" "),r("td",[t._v("50.66")])]),t._v(" "),r("tr",[r("td",[t._v("3")]),t._v(" "),r("td",[t._v("interpreter_opt2")]),t._v(" "),r("td",[t._v("0:47.69")]),t._v(" "),r("td",[t._v("46.79")]),t._v(" "),r("td",[t._v("0.03")]),t._v(" "),r("td",[t._v("46.82")])]),t._v(" "),r("tr",[r("td",[t._v("4")]),t._v(" "),r("td",[t._v("sed")]),t._v(" "),r("td",[t._v("0:19.47")]),t._v(" "),r("td",[t._v("18.17")]),t._v(" "),r("td",[t._v("0.03")]),t._v(" "),r("td",[t._v("18.20")])])])]),t._v(" "),r("p",[t._v("可以發現，interpreter 先經由 jumptable 的優化後， "),r("mark",[t._v("效率直接提升一倍")]),t._v(" ，之後再加上"),r("code",[t._v("contineous_count")]),t._v(" 的運算壓縮後，又快了大約 15 秒，而再加入處理 loop pattern 後，效率反而慢了一點點。但是這些都還沒有 sed 先轉成 C code 再編譯的方法快，"),r("mark",[t._v("原因是因為 interpreter 儘管最佳化，仍需要讀取 BF code 外，每個運算都要經過至少兩個 branch 的指令(for loop + switch case)，而編譯後的 sed 少了很多 branch 指令，自然而然指令數量少，執行效率也會加快很多")]),t._v("，這就是為什麼 interpreter 仍然效率輸 sed 的方法的理由。")]),t._v(" "),r("h2",{attrs:{id:"_5-2-最佳化-interpreter-vs-simple-dynasm-jit"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-最佳化-interpreter-vs-simple-dynasm-jit"}},[t._v("#")]),t._v(" 5.2 最佳化 Interpreter vs  Simple Dynasm JIT")]),t._v(" "),r("Chart",{attrs:{id:"chart_64a55998",code:t.$dataBlock.chart_64a55998}}),r("table",[r("thead",[r("tr",[r("th",[t._v("Rank")]),t._v(" "),r("th",[t._v("program")]),t._v(" "),r("th",[t._v("real")]),t._v(" "),r("th",[t._v("user")]),t._v(" "),r("th",[t._v("system")]),t._v(" "),r("th",[t._v("Execution Time")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("0")]),t._v(" "),r("td",[t._v("interpreter_opt1")]),t._v(" "),r("td",[t._v("1:02.82")]),t._v(" "),r("td",[t._v("61.48")]),t._v(" "),r("td",[t._v("0.01")]),t._v(" "),r("td",[t._v("61.49")])]),t._v(" "),r("tr",[r("td",[t._v("1")]),t._v(" "),r("td",[t._v("interpreter_opt3")]),t._v(" "),r("td",[t._v("0:53.23")]),t._v(" "),r("td",[t._v("50.54")]),t._v(" "),r("td",[t._v("0.12")]),t._v(" "),r("td",[t._v("50.66")])]),t._v(" "),r("tr",[r("td",[t._v("2")]),t._v(" "),r("td",[t._v("interpreter_opt2")]),t._v(" "),r("td",[t._v("0:47.69")]),t._v(" "),r("td",[t._v("46.79")]),t._v(" "),r("td",[t._v("0.03")]),t._v(" "),r("td",[t._v("46.82")])]),t._v(" "),r("tr",[r("td",[t._v("3")]),t._v(" "),r("td",[t._v("jit_dynasm")]),t._v(" "),r("td",[t._v("0:04.75")]),t._v(" "),r("td",[t._v("3.81")]),t._v(" "),r("td",[t._v("0.03")]),t._v(" "),r("td",[t._v("3.84")])])])]),t._v(" "),r("p",[t._v("將 interpreter 引入了 JIT 的技術，在執行時間產生機器碼直接執行，可以看到，無論我們的直譯器做了多少最佳化，真的就是被 JIT 屌打😂。效率直接高了近 15 倍。所以 JIT compiler 的確可以幫我們大幅加速直譯器的執行效率😀。")]),t._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"title"}),r("p",[t._v("你可能會覺得很奇怪，為何同樣是直譯的感覺，不是都是 for loop 後再 switch 執行對應的程式碼嗎 ?")]),t._v(" "),r("p",[t._v("這裡我也想了很久，為何都是指令，p++ 跟 直接執行機器碼的加法執行的就差這麼多 ? 相信很多人都會誤以為就是網路上所說的「直接執行機器碼不用再重新翻譯所以比較快」，這句話是正確的，因為通常 JIT 的實作就是快取常用的機器碼，但在本篇的實作中，如同文章 "),r("a",{attrs:{href:"https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-2-an-x64-jit/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Adventures in JIT compilation: Part 2 - an x64 JIT"),r("OutboundLink")],1),t._v(" 所述")]),t._v(" "),r("blockquote",[r("p",[t._v("The reason is that the baseline performance of the JIT is vastly better. I've mentioned this briefly in part 1 - imagine what's needed to interpret a single instruction in the fastest interpreter.")]),t._v(" "),r("ol",[r("li",[t._v("Advance pc and compare it to program size.")]),t._v(" "),r("li",[t._v("Grab the instruction at pc.")]),t._v(" "),r("li",[t._v("Switch on the value of the instruction to the right case.")]),t._v(" "),r("li",[t._v("Execute the case.")])]),t._v(" "),r("p",[t._v("This requires a whole sequence of machine instructions, with at least two branches (one for the loop, one for the switch). On the other hand, the JIT just emits a single instruction - no branches. I would say that - depending on what the compiler did while compiling the interpreter - the JIT is between 4 and 8 times faster at running any given BF operation. It has to run many more BF operations because it doesn't optimize, but this difference is insufficient to close the huge baseline gap. Later in this post we're going to see an optimized JIT which performs even better.")])]),t._v(" "),r("p",[t._v("事實上， "),r("mark",[t._v("我們的實作方法是先用 for loop 掃一遍，將機器碼存在陣列裡，再用可執行的記憶區段去執行這段陣列")]),t._v(" ，而一般直譯器是每執行一個指令都要經過兩個 branch (for loop + switch)，才能真正執行到運算。因此假設 BF 的 code 是 "),r("code",[t._v("+++")])]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("BF Interpreter")]),t._v(" "),r("th",[t._v("Our BF JIT Compiler")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("jmp branch(loop)"),r("br"),t._v("jmp branch(switch)"),r("br"),t._v("add"),r("br"),t._v("jmp branch(loop)"),r("br"),t._v("jmp branch(switch)"),r("br"),t._v("add"),r("br"),t._v("jmp branch(loop)"),r("br"),t._v("jmp branch(switch)"),r("br"),t._v("add"),r("br")]),t._v(" "),r("td",[t._v("add"),r("br"),t._v("add"),r("br"),t._v("add"),r("br")])])])]),t._v(" "),r("p",[r("mark",[t._v("所以相當於 JIT 先幫我們快速掃了一遍跟判斷，把指令存在一個陣列，再執行一段沒有 branch 的程式碼")]),t._v(" ， 那如同上表，在指令執行的數量上就差很多。一般直譯器可能因為邊讀邊執行，所以每只行一個動作都要多做幾個branch指令，一旦程式碼越大，效能整個就會被拖跨，而在我們 JIT 就是先一次非常快判斷掃一遍，去除所有 branch 的判斷，直接執行純粹的加減法指令，也就是在這裡 JIT 可以贏做一堆前處理、最佳化的直譯器的原因。\n(備註 : Dynasm 幫我們把指令存起來再放入可執行記憶體區段執行，這篇"),r("a",{attrs:{href:"https://blog.reverberate.org/2012/12/hello-jit-world-joy-of-simple-jits.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("文章"),r("OutboundLink")],1),t._v(" 對於 Dynasm 講的蠻詳細的 )")])]),r("p",[t._v("::: info\n這種直譯的 for loop 搭配 switch case 的 overhead 有個專有名詞叫做 "),r("mark",[t._v("dispatch loop 或 dynamic dispatch")]),t._v("，如果像是 BF 這種比較簡單的直譯，那 dispatch 的成本佔執行時間的比例就會較大，而傳統會使用 threaded code 手法加速，這種加速手法會更明顯。這個方法之後會加入分析。也有做法是將全部程式碼都一次展開，如同本次 JIT 一樣，用空間換時間的方法，再用 threaded code 進行最佳化。\n:::")]),t._v(" "),r("h2",{attrs:{id:"_5-3-站在顛峰-最快的辣些人"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-站在顛峰-最快的辣些人"}},[t._v("#")]),t._v(" 5.3 站在顛峰 - 最快的辣些人")]),t._v(" "),r("Chart",{attrs:{id:"chart_64a54ae2",code:t.$dataBlock.chart_64a54ae2}}),r("table",[r("thead",[r("tr",[r("th",[t._v("Rank")]),t._v(" "),r("th",[t._v("program")]),t._v(" "),r("th",[t._v("real")]),t._v(" "),r("th",[t._v("user")]),t._v(" "),r("th",[t._v("system")]),t._v(" "),r("th",[t._v("Execution Time")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("0")]),t._v(" "),r("td",[t._v("jit_opcode")]),t._v(" "),r("td",[t._v("0:04.35")]),t._v(" "),r("td",[t._v("3.89")]),t._v(" "),r("td",[t._v("0.03")]),t._v(" "),r("td",[t._v("3.92")])]),t._v(" "),r("tr",[r("td",[t._v("1")]),t._v(" "),r("td",[t._v("compiler")]),t._v(" "),r("td",[t._v("0:04.20")]),t._v(" "),r("td",[t._v("3.85")]),t._v(" "),r("td",[t._v("0.00")]),t._v(" "),r("td",[t._v("3.85")])]),t._v(" "),r("tr",[r("td",[t._v("2")]),t._v(" "),r("td",[t._v("jit_dynasm")]),t._v(" "),r("td",[t._v("0:04.75")]),t._v(" "),r("td",[t._v("3.81")]),t._v(" "),r("td",[t._v("0.03")]),t._v(" "),r("td",[t._v("3.84")])]),t._v(" "),r("tr",[r("td",[t._v("3")]),t._v(" "),r("td",[t._v("jit_dynasm_opt2")]),t._v(" "),r("td",[t._v("0:01.37")]),t._v(" "),r("td",[t._v("1.25")]),t._v(" "),r("td",[t._v("0.01")]),t._v(" "),r("td",[t._v("1.26")])]),t._v(" "),r("tr",[r("td",[t._v("4")]),t._v(" "),r("td",[t._v("jit_dynasm_opt1")]),t._v(" "),r("td",[t._v("0:01.46")]),t._v(" "),r("td",[t._v("1.25")]),t._v(" "),r("td",[t._v("0.00")]),t._v(" "),r("td",[t._v("1.25")])]),t._v(" "),r("tr",[r("td",[t._v("5")]),t._v(" "),r("td",[t._v("sed_O2")]),t._v(" "),r("td",[t._v("0:01.21")]),t._v(" "),r("td",[t._v("1.20")]),t._v(" "),r("td",[t._v("0.00")]),t._v(" "),r("td",[t._v("1.20")])]),t._v(" "),r("tr",[r("td",[t._v("6")]),t._v(" "),r("td",[t._v("sed_O1")]),t._v(" "),r("td",[t._v("0:01.20")]),t._v(" "),r("td",[t._v("1.17")]),t._v(" "),r("td",[t._v("0.01")]),t._v(" "),r("td",[t._v("1.18")])]),t._v(" "),r("tr",[r("td",[t._v("7")]),t._v(" "),r("td",[t._v("sed_O3")]),t._v(" "),r("td",[t._v("0:01.18")]),t._v(" "),r("td",[t._v("1.17")]),t._v(" "),r("td",[t._v("0.00")]),t._v(" "),r("td",[t._v("1.17")])])])]),t._v(" "),r("p",[t._v("在還沒做任何最佳化前(contineous_count, loop pattern)，我們實做的方法最多只能到4秒左右，但是加入了 Part4 提到的最佳化技術後，整體又快了3秒。執行效率1秒多。使得我們實做的 just in time compiler 逼近 clang 編譯器進行程式碼最佳化後的效率。很厲害吧!😉")]),t._v(" "),r("h2",{attrs:{id:"_5-4-結尾和未來工作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-結尾和未來工作"}},[t._v("#")]),t._v(" 5.4 結尾和未來工作")]),t._v(" "),r("p",[t._v("我們實作了不同的方法去執行運算量大的碎形 brainfuck 程式檔，最後利用及時編譯技術加上一些最佳化方法，把 "),r("mark",[t._v("普通的 interpreter 效率提升 120 倍")]),t._v("，執行只需要 1 秒，可以說是非常值得使用及深入探討的技術。至於未來工作是加入 LLVM 及 asmjit 這兩個工具幫我們建立 JIT 編譯器，並且加入比較，且把組合語言的基礎打穩。")]),t._v(" "),r("h2",{attrs:{id:"_5-5-參考連結-特別感謝的網站"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-參考連結-特別感謝的網站"}},[t._v("#")]),t._v(" 5.5 參考連結 (特別感謝的網站)")]),t._v(" "),r("ol",[r("li",[r("p",[r("a",{attrs:{href:"https://nickdesaulniers.github.io/blog/2015/05/25/interpreter-compiler-jit/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Interpreter, Compiler, JIT"),r("OutboundLink")],1)])]),t._v(" "),r("li",[r("p",[r("a",{attrs:{href:"http://accu.cc/content/jit_tour/brainfuck_jit/",target:"_blank",rel:"noopener noreferrer"}},[t._v("JIT 編譯器原理簡述/實現Brainfuck JIT 編譯器"),r("OutboundLink")],1)])]),t._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://hackmd.io/@nKngvyhpQdGagg1V6GKLwA/HJjoxbvke?type=view#2016q3-Homework5---JIT-compiler",target:"_blank",rel:"noopener noreferrer"}},[t._v("2016q3 Homework5 - JIT compiler"),r("OutboundLink")],1)])]),t._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://hackmd.io/@sysprog/SkBsZoReb?type=view",target:"_blank",rel:"noopener noreferrer"}},[t._v("虛擬機器設計與實作"),r("OutboundLink")],1)])]),t._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-1-an-interpreter/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Adventures in JIT compilation: Part 1 - an interpreter"),r("OutboundLink")],1)])]),t._v(" "),r("li",[r("p",[r("a",{attrs:{href:"https://eli.thegreenplace.net/2017/adventures-in-jit-compilation-part-2-an-x64-jit/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Adventures in JIT compilation: Part 2 - an x64 JIT"),r("OutboundLink")],1)])])])],1)}),[],!1,null,null,null);"function"==typeof v&&v(n);_.default=n.exports}}]);